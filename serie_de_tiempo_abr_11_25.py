# -*- coding: utf-8 -*-
"""Serie de Tiempo Abr 11 25

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YaTlaToA_TwJLhMjcI4MiCowVxAn11Ce
"""

import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from statsmodels.tsa.stattools import coint
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.regression.linear_model import OLS
from datetime import datetime

# Define the stocks and time period
tickers = ['GOOG', 'META', 'PLTR']
start_date = '2020-10-01'  # After PLTR IPO (Sept 30, 2020)
end_date = datetime.today().strftime('%Y-%m-%d')

# Portfolio weights from the table (Porcentajes)
weights = {
    'GOOG': 0.231,  # 23.1%
    'META': 0.211,  # 21.1%
    'PLTR': 0.096   # 9.6%
}

# Fetch historical data
print("Fetching data...")
data = yf.download(tickers, start=start_date, end=end_date, auto_adjust=True)
print("Data columns:", data.columns)

# Check if data was fetched successfully
if data.empty or not all(('Close', ticker) in data.columns for ticker in tickers):
    raise ValueError("Failed to fetch data for one or more tickers. Please check ticker symbols or internet connection.")

# Drop any rows with NaN values in the historical data
data = data.dropna()

# Parameters for random walk
n_steps = 252  # Number of trading days to simulate (approx 1 year)

# Function to simulate random walk with unit root
def random_walk_unit_root(start_price, n_steps, volatility):
    steps = np.random.normal(0, volatility, n_steps)
    walk = start_price + np.cumsum(steps)
    return walk

# Simulate random walks for each stock
simulated_data = {}
dates = pd.date_range(start=start_date, periods=n_steps, freq='B')

for ticker in tickers:
    start_price = data[('Close', ticker)].iloc[0]
    historical_volatility = data[('Close', ticker)].pct_change().std()

    if np.isnan(historical_volatility):
        raise ValueError(f"Volatility for {ticker} is NaN. Check historical data for missing values.")

    rw = random_walk_unit_root(start_price, n_steps, historical_volatility)
    if np.any(np.isnan(rw)):
        raise ValueError(f"Simulated data for {ticker} contains NaN values.")

    simulated_data[ticker] = rw

# Convert simulated data to DataFrame
simulated_df = pd.DataFrame(simulated_data, index=dates)

# Test for cointegration
print("\nCointegration Test Results:")
cointegration_results = {}
for i, ticker1 in enumerate(tickers):
    for j, ticker2 in enumerate(tickers[i+1:], i+1):
        score, p_value, _ = coint(simulated_df[ticker1], simulated_df[ticker2])
        cointegration_results[(ticker1, ticker2)] = p_value
        print(f"{ticker1} vs {ticker2}: p-value = {p_value:.4f}")
        if p_value < 0.05:
            print(f"  -> Evidence of cointegration (p < 0.05)")

# Plotting setup for random walks and correlograms
fig = plt.figure(figsize=(15, 15))
fig.suptitle('Random Walk Simulations, Correlograms, and Cointegration Analysis from Oct 1, 2020', fontsize=16)

# Plot random walks and correlograms
for i, ticker in enumerate(tickers):
    start_price = data[('Close', ticker)].iloc[0]

    # Random walk plot
    plt.subplot(4, 2, 2*i + 1)
    plt.plot(simulated_df.index, simulated_df[ticker], label=f'{ticker} Random Walk', color='blue')
    plt.axhline(y=start_price, color='red', linestyle='--', label='Starting Price')
    plt.title(f'{ticker} Random Walk')
    plt.xlabel('Date')
    plt.ylabel('Price ($)')
    plt.legend()
    plt.xticks(rotation=45)

    # Correlogram (ACF)
    plt.subplot(4, 2, 2*i + 2)
    plot_acf(simulated_df[ticker], ax=plt.gca(), lags=20, title=f'{ticker} Correlogram')

# Plot cointegration residuals for GOOG vs META
ticker1, ticker2 = 'GOOG', 'META'
p_value = cointegration_results[(ticker1, ticker2)]
# Fit a linear regression to find the cointegrating relationship
X = simulated_df[ticker1]
y = simulated_df[ticker2]
model = OLS(y, X).fit()
residuals = y - model.predict(X)

# Plot residuals
plt.subplot(4, 2, 7)
plt.plot(simulated_df.index, residuals, label='Residuals', color='purple')
plt.axhline(y=0, color='black', linestyle='--')
plt.title(f'Cointegration Residuals: {ticker1} vs {ticker2} (p-value = {p_value:.4f})')
plt.xlabel('Date')
plt.ylabel('Residuals')
plt.legend()
plt.xticks(rotation=45)

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

# Print results for explanation
for ticker in tickers:
    start_price = data[('Close', ticker)].iloc[0]
    historical_volatility = data[('Close', ticker)].pct_change().std() * np.sqrt(252)
    print(f"\nResults for {ticker}:")
    print(f"Starting Price (Oct 1, 2020): ${start_price:.2f}")
    print(f"Annualized Historical Volatility: {historical_volatility:.2%}")
    print(f"Portfolio Weight: {weights[ticker]*100:.1f}%")